/* Section 1: Options */
options { JAVA_UNICODE_ESCAPE = true; }

/* Section 2: Driver */
PARSER_BEGIN(HOPE1)

import java.io.FileInputStream;
import java.io.IOException;
import java.io.FileNotFoundException;

public class HOPE1 {

   public static void main(String args[]) {

      HOPE1 parser = null;

      if(args.length == 0) {
         System.out.println("Reading input...");
         parser = new HOPE1(System.in);
      }
      else if(args.length == 1) {
         try {
            parser = new HOPE1(new FileInputStream(args[0]));
         }
         catch(FileNotFoundException e) {
            System.err.println("File " + args[0] + " not found");
            return;
         }
      }
      else {
         System.out.println("You must use the following format:");
         System.out.println("java HOPE1 inputfile");
      }

      try{
         parser.program();
      }
      catch(ParseException e) {
         System.out.println(e.getMessage());
      }
   }

}

PARSER_END(HOPE1)

/* Section 3: Token Definitions */
TOKEN_MGR_DECLS : { static int commentNesting = 0; }

/* Ignores whitespace characters */
SKIP : {
   " " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */
SKIP : {
   "/*" { commentNesting++; } : IN_COMMENT |
   "//" : IN_SINGLE_LINE_COMMENT
}

<IN_COMMENT> SKIP: {
   "/*" { commentNesting++; } |
   "*/" { commentNesting--; if(commentNesting == 0) { SwitchTo(DEFAULT); } } |
   <~[]>
}

<IN_SINGLE_LINE_COMMENT> SKIP: {
   <"\n" | "\r" | "\r\n"> : DEFAULT |
   <~[]>
}

TOKEN [IGNORE_CASE] : /* Keywords */
{
    <PRINT : "print">
}

TOKEN : /* Punctuation */
{
   <LBR : "("> |
   <RBR : ")"> |
   <SEMIC : ";"> |
   <PLUS_SIGN : "+"> |
   <MINUS_SIGN : "-"> |
   <MUL_SIGN : "*"> |
   <DIV_SIGN : "/">
}

TOKEN : /* Numbers and identifiers */
{
   <NUM : ("0" | <INTEGER_LITERAL>)> |
   <#INTEGER_LITERAL : (["-"])?["1"-"9"](["0"-"9"])*>
}

TOKEN : /* Unrecognized tokens */
{
    <OTHER : ~[]>
}

/* Section 4: Grammar */

void program() : {}
{
   statement_block() <EOF>
}

void statement_block() : {}
{
   statement() <SEMIC> statement_block() | {}
}

void statement() : {}
{
   <PRINT> <LBR> expression() <RBR>
}

void expression() : {}
{
   fragment() binary_arith_op() fragment() (binary_arith_op() fragment())*
}

void fragment() : {}
{
   <NUM>
}

void binary_arith_op() : {}
{
   <PLUS_SIGN> | <MINUS_SIGN> | <MUL_SIGN> | <DIV_SIGN>
}
