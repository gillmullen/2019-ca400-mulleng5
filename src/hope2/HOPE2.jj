/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. HOPE2.jj */
/*@egen*//* Section 1: Options */
options {
                
                  
   JAVA_UNICODE_ESCAPE = true;
}

/* Section 2: Driver */
PARSER_BEGIN(HOPE2)

import java.io.FileInputStream;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.io.BufferedWriter;
import java.io.FileWriter;

public class HOPE2/*@bgen(jjtree)*/implements HOPE2TreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTHOPE2State jjtree = new JJTHOPE2State();

/*@egen*/

   public static SymbolTable st = new SymbolTable();

   public static void main(String args[]) {

      HOPE2 parser = null;
      String irFileName = "HOPE2.ll";

      if(args.length == 0) {
         System.out.println("Reading input...");
         parser = new HOPE2(System.in);
      }
      else if(args.length == 1) {
         try {
            parser = new HOPE2(new FileInputStream(args[0]));
            irFileName = args[0] + ".ll";
         }
         catch(FileNotFoundException e) {
            System.err.println("File " + args[0] + " not found");
            return;
         }
      }
      else {
         System.out.println("You must use the following format:");
         System.out.println("java HOPE2 inputfile");
      }

      try{
         SimpleNode root = parser.program();

         System.out.println("Abstract Syntax Tree:");
         root.dump(">");

         System.out.println("\nProgram:");
         PrintVisitor pv = new PrintVisitor();
         root.jjtAccept(pv, "");

         System.out.println("\nSymbol Table:");
         st.print();

         System.out.println("\nSemantic Analysis:");
         SemanticVisitor sv = new SemanticVisitor();
         root.jjtAccept(sv, st);

         System.out.println("\nWriting LLVM code to: " + irFileName);

         try {
            Context c = new Context(new BufferedWriter(new FileWriter(irFileName)));
            IrCodeVisitor irCode = new IrCodeVisitor();
            root.jjtAccept(irCode, c);
            c.buffer.flush();
         }
         catch (IOException e) {
            System.out.println("Failed to write LLVM code to file");
            e.printStackTrace(System.out);
         }

      }
      catch(ParseException e) {
         System.out.println(e.getMessage());
      }
   }

}

PARSER_END(HOPE2)

/* Section 3: Token Definitions */
TOKEN_MGR_DECLS : { static int commentNesting = 0; }

/* Ignores whitespace characters */
SKIP : {
   " " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */
SKIP : {
   "/*" { commentNesting++; } : IN_COMMENT |
   "//" : IN_SINGLE_LINE_COMMENT
}

<IN_COMMENT> SKIP: {
   "/*" { commentNesting++; } |
   "*/" { commentNesting--; if(commentNesting == 0) { SwitchTo(DEFAULT); } } |
   <~[]>
}

<IN_SINGLE_LINE_COMMENT> SKIP: {
   <"\n" | "\r" | "\r\n"> : DEFAULT |
   <~[]>
}

TOKEN [IGNORE_CASE] : /* Keywords */
{
    <PRINT : "print"> |
    <INT : "int">
}

TOKEN : /* Punctuation */
{
   <LBR : "("> |
   <RBR : ")"> |
   <SEMIC : ";"> |
   <PLUS_SIGN : "+"> |
   <MINUS_SIGN : "-"> |
   <MUL_SIGN : "*"> |
   <DIV_SIGN : "/"> |
   <EQUALS : "=">
}

TOKEN : /* Numbers and identifiers */
{
   <NUM : ("0" | <INTEGER_LITERAL>)> |
   <#INTEGER_LITERAL : ["1"-"9"](["0"-"9"])*> |
   <ID : <LETTER>(<LETTER> | <INTEGER_LITERAL> | "_")*> |
   <#LETTER : ["A"-"Z","a"-"z"]>
}

TOKEN : /* Unrecognized tokens */
{
    <OTHER : ~[]>
}

/* Section 4: Grammar */

SimpleNode program() : {/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) program */
   try {
/*@egen*/
   statement_block() <EOF>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void statement_block() : {/*@bgen(jjtree) statement_block */
  ASTstatement_block jjtn000 = new ASTstatement_block(JJTSTATEMENT_BLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement_block */
   try {
/*@egen*/
   statement() statement_block() |/*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                   }
/*@egen*/ {}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void statement() : {/*@bgen(jjtree) statement */
  ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
   try {
/*@egen*/
   print() |
   assignment() |
   declaration()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void expression()       : {}
{
   fragment() (binary_arith_op()/*@bgen(jjtree) #expression( 3) */
                                 {
                                   ASTexpression jjtn001 = new ASTexpression(JJTEXPRESSION);
                                   boolean jjtc001 = true;
                                   jjtree.openNodeScope(jjtn001);
                                 }
                                 try {
/*@egen*/ fragment()/*@bgen(jjtree)*/
                                 } catch (Throwable jjte001) {
                                   if (jjtc001) {
                                     jjtree.clearNodeScope(jjtn001);
                                     jjtc001 = false;
                                   } else {
                                     jjtree.popNode();
                                   }
                                   if (jjte001 instanceof RuntimeException) {
                                     throw (RuntimeException)jjte001;
                                   }
                                   if (jjte001 instanceof ParseException) {
                                     throw (ParseException)jjte001;
                                   }
                                   throw (Error)jjte001;
                                 } finally {
                                   if (jjtc001) {
                                     jjtree.closeNodeScope(jjtn001,  3);
                                   }
                                 }
/*@egen*/               )*
}

void fragment()       : {}
{
   integer() | rhs_identifier()
}

void integer() : {/*@bgen(jjtree) integer */
                   ASTinteger jjtn000 = new ASTinteger(JJTINTEGER);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) integer */
   try {
/*@egen*/
   ( t = <NUM> )/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/  { jjtn000.value = t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void assignment() : {/*@bgen(jjtree) assignment */
  ASTassignment jjtn000 = new ASTassignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) assignment */
   try {
/*@egen*/
   lhs_identifier() <EQUALS> expression() <SEMIC>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void declaration() : {/*@bgen(jjtree) declaration */
                       ASTdeclaration jjtn000 = new ASTdeclaration(JJTDECLARATION);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ String id; }
{/*@bgen(jjtree) declaration */
   try {
/*@egen*/
   type() id = lhs_identifier() <SEMIC>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/ { st.insert(id); }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void print() : {/*@bgen(jjtree) print */
  ASTprint jjtn000 = new ASTprint(JJTPRINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) print */
   try {
/*@egen*/
   <PRINT> <LBR> expression() <RBR> <SEMIC>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

String lhs_identifier() : {/*@bgen(jjtree) lhs_identifier */
                            ASTlhs_identifier jjtn000 = new ASTlhs_identifier(JJTLHS_IDENTIFIER);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) lhs_identifier */
   try {
/*@egen*/
   ( t = <ID> )/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { jjtn000.value = t.image; return t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

String rhs_identifier() : {/*@bgen(jjtree) rhs_identifier */
                            ASTrhs_identifier jjtn000 = new ASTrhs_identifier(JJTRHS_IDENTIFIER);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) rhs_identifier */
   try {
/*@egen*/
   ( t = <ID> )/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { jjtn000.value = t.image; return t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

String type() : {/*@bgen(jjtree) type */
                  ASTtype jjtn000 = new ASTtype(JJTTYPE);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) type */
   try {
/*@egen*/
   ( t = <INT> )/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.value = t.image; return t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void binary_arith_op() : {/*@bgen(jjtree) binary_arith_op */
                           ASTbinary_arith_op jjtn000 = new ASTbinary_arith_op(JJTBINARY_ARITH_OP);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) binary_arith_op */
   try {
/*@egen*/
   ( t = <PLUS_SIGN> | t = <MINUS_SIGN> | t = <MUL_SIGN> | t = <DIV_SIGN> )/*@bgen(jjtree)*/
                                                                            {
                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
                                                                            }
/*@egen*/ { jjtn000.value = t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}
